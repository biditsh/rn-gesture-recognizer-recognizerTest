import React from 'react';
import {View, PanResponder, StyleSheet, Button, TextInput, TouchableOpacity, Text} from 'react-native';
import Pen from '../tools/pen';
import Point from '../tools/point';
import Svg, {G, Path} from 'react-native-svg';
import gestureRecognizer from '../tools/rubine';
let RNFS = require('react-native-fs'); // for writing json files

export default class Trainer extends React.Component {
	constructor(props, context) {
		super(props, context);

		// Initial exportable object, to be stored in state
		let writeObj = {
			gestureClasses: []
		}

		this.state = {
			currentPoints: [],
			previousStrokes: this.props.strokes || [],
			newStroke: [],
			gestureClassPoints: [],
			pen: new Pen(),
			currGestureClassName: "gestureClassName",
			symmetrical: false,
			gestureClassOutputFile: writeObj,
		};

		this._panResponder = PanResponder.create({
			onStartShouldSetPanResponder: (evt, gs) => true,
			onMoveShouldSetPanResponder: (evt, gs) => true,
			onPanResponderGrant: (evt, gs) => this.onResponderGrant(evt, gs),
			onPanResponderMove: (evt, gs) => this.onResponderMove(evt, gs),
			onPanResponderRelease: (evt, gs) => this.onResponderRelease(evt, gs),
		});
	}

	componentWillReceiveProps(newProps) {
		if (
			this.props.strokes &&
			newProps.strokes &&
			JSON.stringify(this.props.strokes) !== JSON.stringify(newProps.strokes)
		) {
			this.setState({
				previousStrokes: newProps.strokes,
				newStroke: [],
			});
		}
	}

	toggleSymmetricalSelectButton = () => {
		this.setState({symmetrical: !this.state.symmetrical})
	} 


	SymmetricalSelectButton() {
		return (
			<TouchableOpacity style={{ flexDirection:'row' }} onPress={this.toggleSymmetricalSelectButton}>
				<View style={[{
				height: 18,
				width: 18,
				borderRadius: 8,
				borderWidth: 2,
				borderColor: '#000',
				alignItems: 'center',
				justifyContent: 'center',
				}]}>
				{
					this.state.symmetrical ?
					<View style={{
						height: 12,
						width: 12,
						borderRadius: 6,
						backgroundColor: '#000',
					}}/>
					: null
				}
				</View>
				<Text> Symmetrical </Text>
			</TouchableOpacity>
		);
	  }
	
	// Undo the previous stroke, remove the last added gesture from the current gesture class
	rewind = () => {
		if (
			this.state.currentPoints.length > 0 ||
			this.state.previousStrokes.length < 1
		) {
			return;
		}
		let previousStrokes = this.state.previousStrokes;
		previousStrokes.pop();

		let gestureClassPoints = this.state.gestureClassPoints;
		gestureClassPoints.pop();

		this.state.pen.rewindStroke();

		this.setState(
			{
				gestureClassPoints,
				previousStrokes,
				currentPoints: [],
			},
			() => {
				this._onChangeStrokes([...previousStrokes]);
			},
		);
	};

	// Clear the pad, remove all gestures from the current gesture class
	clear = () => {
		this.setState(
			{
				previousStrokes: [],
				gestureClassPoints: [],
				currentPoints: [],
				newStroke: [],
			},
			() => {
				this._onChangeStrokes([]);
			},
		);

		this.state.pen.clear();
	};

	// Add the current gesture class to the output object, then reset everything else
	saveAndAddNewGestureClass = () => {
		let writeObj = this.state.gestureClassOutputFile;
		let currGestureClass = {
			'gestureClassName': this.state.currGestureClassName,
			'trainingGestures': this.state.gestureClassPoints,
		}
		writeObj.gestureClasses.push(currGestureClass);

		this.setState({
			currentPoints: [],
			previousStrokes: [],
			newStroke: [],
			gestureClassPoints: [],
			pen: new Pen(),
			currGestureClassName: "gestureClassName",
			symmetrical: false,
			gestureClassOutputFile: writeObj
		})
	}

	// Write the current gesture class to the model.json file
	exportGestureClass = () => {
		// if they haven't saved the current gesture, add it to the object
		if (this.state.gestureClassPoints.length != 0 && this.state.currGestureClassName.length != 0) {
			this.saveAndAddNewGestureClass();
		}

		console.log(this.state.gestureClassOutputFile);

		if (this.state.gestureClassOutputFile.gestureClasses.length > 0) {
			// let gestureTrainingObject = JSON.stringify(this.state.gestureClassOutputFile);
			let gestureTrainingObject = this.state.gestureClassOutputFile.gestureClasses;
			let myRecognizer = new gestureRecognizer(gestureTrainingObject);
			let writeObj = myRecognizer.exportValues();

			const path = this.props.path + '/model.json';
			RNFS.writeFile(path, JSON.stringify(writeObj), 'utf8')
				.then(success => {
					console.log('model written!');
				})
				.catch(err => {
					console.log(err.message);
				});
	
			// on export, reset everything but the writeObject!
			this.setState({
				currentPoints: [],
				previousStrokes: this.props.strokes || [],
				newStroke: [],
				gestureClassPoints: [],
				pen: new Pen(),
				currGestureClassName: "gestureClassName",
				symmetrical: false
			});
		}
	};

	// Called on all touch events from the PanResponder
	onTouch(evt) {
		let x, y, timestamp;
		[x, y, timestamp] = [
			evt.nativeEvent.locationX,
			evt.nativeEvent.locationY,
			evt.nativeEvent.timestamp,
		];
		let newPoint = new Point(x, y, timestamp);
		let newCurrentPoints = this.state.currentPoints;
		newCurrentPoints.push(newPoint);

		this.setState({
			previousStrokes: this.state.previousStrokes,
			currentPoints: newCurrentPoints,
		});
	}

	onResponderGrant(evt) {
		this.onTouch(evt);
	}

	onResponderMove(evt) {
		this.onTouch(evt);
	}

	// update state with all data from the last gesture made
	onResponderRelease() {
		let points = this.state.currentPoints;

		if (points.length < 1) return;
		if (points.length === 1) {
			let p = points[0];
			let distance = parseInt(Math.sqrt(this.props.strokeWidth || 4) / 2);
			points.push(new Point(p.X + distance, p.Y + distance, p.time));
		}

		let newElement = {
			type: 'Path',
			attributes: {
				d: this.state.pen.pointsToSvg(points),
				stroke: '#9b6ed69e', // added stroke will be a different color and partially transparent
				strokeWidth: this.props.strokeWidth || 4,
				fill: 'none',
				strokeLinecap: 'round',
				strokeLinejoin: 'round',
			},
		};

		this.state.pen.addStroke(points);
		this.setState(
			{
				previousStrokes: [...this.state.previousStrokes, newElement],
				gestureClassPoints: [...this.state.gestureClassPoints, points],
				currentPoints: [],
			},
			() => {
				this._onChangeStrokes(this.state.previousStrokes);
			},
		);
	}

	_onChangeStrokes = strokes => {
		if (this.props.onChangeStrokes) {
			this.props.onChangeStrokes(strokes);
		}
	};

	_onLayoutContainer = e => {
		this.state.pen.setOffset(e.nativeEvent.layout);
		this._layout = e.nativeEvent.layout;
	};

	_renderSvgElement = (e, tracker) => {
		if (e.type === 'Path') {
			return <Path {...e.attributes} key={tracker} />;
		}

		return null;
	};

	render() {
		// console.log(this.state.gestureClassPoints);
		if (this.state.gestureClassOutputFile != null) {

		}
		let symmetricalSelect = this.SymmetricalSelectButton()
		return (
			<View style={{flex: 1, alignItems: 'stretch'}}>
				{/* The Original RN-Draw Component */}
				<View onLayout={this._onLayoutContainer} style={[styles.drawContainer, this.props.containerStyle]}>
					<View style={styles.svgContainer} {...this._panResponder.panHandlers}>
						<Svg style={styles.drawSurface}>
							<G>
								{this.state.previousStrokes.map((stroke, index) => {
									return this._renderSvgElement(stroke, index);
								})}
								<Path
									key={this.state.previousStrokes.length}
									d={this.state.pen.pointsToSvg(this.state.currentPoints)}
									stroke={this.props.color || '#000000'}
									strokeWidth={this.props.strokeWidth || 4}
									fill="none"
									strokeLinecap="round"
									strokeLinejoin="round"
								/>
							</G>
						</Svg>
						{this.props.children}
					</View>
				</View>

				<View style={styles.nameClass}>
				<TextInput style= {{flex: 2, textAlign: 'center'}}
					onChangeText={(text) => this.setState({currGestureClassName: text})}
					value={this.state.currGestureClassName}/>
					{symmetricalSelect}
				</View>

				<View style={styles.button}>
					<Button onPress={this.clear} title="Clear" />
					<Button onPress={this.rewind} title="Undo" />
					<Button onPress={this.saveAndAddNewGestureClass} title="New" />
					<Button onPress={this.exportGestureClass} title="Export" />
				</View>
			</View>
		);
	}
}


let styles = StyleSheet.create({
	drawContainer: {
		flex: 1,
		display: 'flex',
		backgroundColor: '#e0e4e5',
	},
	svgContainer: {
		flex: 1,
	},
	drawSurface: {
		flex: 1,
	},
	button: {
		flexDirection: 'row',
		justifyContent: 'space-between',
		backgroundColor: '#c1c1ba'
	},
	nameClass: {
		flexDirection: 'row',
	}
});
